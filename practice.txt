using System;
using System.Collections.Generic;
using System.Drawing;
using System.Linq;
using System.Windows.Forms;

public partial class Form1 : Form
{
    private List<City> cities;
    private PSO pso;
    private Particle bestSolution;
    private Timer timer;
    private int iterationCount = 0;
    private const int maxIterationsWithoutImprovement = 500;
    private double bestDistanceSoFar = double.MaxValue;
    private int iterationsWithoutImprovement = 0;

    public Form1()
    {
        InitializeComponent();

        // Initialize cities
        cities = new List<City>()
        {
            new City(100, 100),
            new City(200, 100),
            new City(300, 200),
            new City(400, 300),
            new City(500, 400),
            new City(600, 100)
        };

        // Initialize PSO
        pso = new PSO(cities, swarmSize: 50);

        // Set up a timer to continuously run PSO optimization
        timer = new Timer();
        timer.Interval = 100; // Adjust this value to speed up/slow down visualization
        timer.Tick += Timer_Tick;
        timer.Start();
    }

    private void Timer_Tick(object sender, EventArgs e)
    {
        // Run one iteration of optimization
        pso.Optimize(iterations: 1);
        bestSolution = pso.GetBestSolution();
        iterationCount++;

        // Check for stopping condition
        if (bestSolution.BestFitness < bestDistanceSoFar)
        {
            bestDistanceSoFar = bestSolution.BestFitness;
            iterationsWithoutImprovement = 0;
        }
        else
        {
            iterationsWithoutImprovement++;
        }

        if (iterationsWithoutImprovement >= maxIterationsWithoutImprovement)
        {
            timer.Stop(); // Stop optimization if no improvement in a long time
            MessageBox.Show($"Optimization stopped after {iterationCount} iterations. Best distance: {bestDistanceSoFar}");
        }

        // Invalidate the form to trigger a redraw with the updated best solution
        this.Invalidate();
    }

    protected override void OnPaint(PaintEventArgs e)
    {
        base.OnPaint(e);
        if (bestSolution != null)
        {
            DrawCitiesAndPath(e.Graphics, bestSolution);
        }
    }

    private void DrawCitiesAndPath(Graphics g, Particle solution)
    {
        Pen pen = new Pen(Color.Black, 2);
        Brush cityBrush = new SolidBrush(Color.Red);
        Font font = new Font("Arial", 10);
        Brush textBrush = new SolidBrush(Color.Blue);

        // Draw cities as red dots
        for (int i = 0; i < cities.Count; i++)
        {
            City city = cities[i];
            g.FillEllipse(cityBrush, (float)city.X - 5, (float)city.Y - 5, 10, 10);
            g.DrawString($"City {i + 1}", font, textBrush, (float)city.X + 10, (float)city.Y);
        }

        // Draw the optimized path between the cities
        for (int i = 0; i < solution.Position.Count - 1; i++)
        {
            City city1 = cities[solution.Position[i]];
            City city2 = cities[solution.Position[i + 1]];
            g.DrawLine(pen, (float)city1.X, (float)city1.Y, (float)city2.X, (float)city2.Y);
        }

        // Draw the line from the last city back to the first
        City lastCity = cities[solution.Position.Last()];
        City firstCity = cities[solution.Position.First()];
        g.DrawLine(pen, (float)lastCity.X, (float)lastCity.Y, (float)firstCity.X, (float)firstCity.Y);

        // Display iteration count for debugging purposes
        g.DrawString($"Iteration: {iterationCount}", font, textBrush, 10, 10);
        g.DrawString($"Best Distance: {bestDistanceSoFar:F2}", font, textBrush, 10, 30);
    }
}





using System;
using System.Collections.Generic;
using System.Linq;

public class PSO
{
    private List<Particle> swarm;
    private List<City> cities;
    private int swarmSize;
    private Particle globalBest;
    private Random random = new Random();

    public PSO(List<City> cities, int swarmSize)
    {
        this.cities = cities;
        this.swarmSize = swarmSize;
        swarm = new List<Particle>();
        globalBest = null;

        InitializeSwarm();
    }

    private void InitializeSwarm()
    {
        List<int> initialPosition = Enumerable.Range(0, cities.Count).ToList();
        for (int i = 0; i < swarmSize; i++)
        {
            Particle particle = new Particle(new List<int>(initialPosition));
            particle.Shuffle();
            particle.Fitness = CalculateTotalDistance(particle.Position, cities);
            particle.UpdateBestPosition();

            swarm.Add(particle);
            if (globalBest == null || particle.Fitness < globalBest.Fitness)
            {
                globalBest = particle;
            }
        }
    }

    public void Optimize(int iterations, double inertiaWeight = 0.5, double cognitiveComponent = 1.5, double socialComponent = 1.5)
    {
        for (int iter = 0; iter < iterations; iter++)
        {
            foreach (var particle in swarm)
            {
                // Update fitness
                particle.Fitness = CalculateTotalDistance(particle.Position, cities);
                particle.UpdateBestPosition();

                // Update global best
                if (particle.Fitness < globalBest.Fitness)
                {
                    globalBest = particle;
                }

                // Update particle's velocity
                particle.UpdateVelocity(globalBest.Position, inertiaWeight, cognitiveComponent, socialComponent);

                // Apply the velocity (swap operations)
                particle.ApplyVelocity();
            }
        }
    }

    public Particle GetBestSolution()
    {
        return globalBest;
    }

    private double CalculateTotalDistance(List<int> route, List<City> cities)
    {
        double distance = 0;
        for (int i = 0; i < route.Count - 1; i++)
        {
            distance += cities[route[i]].DistanceTo(cities[route[i + 1]]);
        }
        distance += cities[route[route.Count - 1]].DistanceTo(cities[route[0]]); // Return to starting point
        return distance;
    }
}






using System;
using System.Collections.Generic;
using System.Linq;

public class Particle
{
    public List<int> Position { get; set; } // The order of cities (potential solution)
    public List<int> BestPosition { get; set; } // Personal best position
    public double BestFitness { get; set; } // Best distance so far
    public double Fitness { get; set; } // Current fitness (distance)
    public List<Tuple<int, int>> Velocity { get; set; } // Swap operations representing velocity

    private Random random = new Random();

    public Particle(List<int> position)
    {
        Position = new List<int>(position);
        BestPosition = new List<int>(position);
        BestFitness = double.MaxValue;
        Velocity = new List<Tuple<int, int>>();
    }

    public void Shuffle()
    {
        int n = Position.Count;
        for (int i = 0; i < n; i++)
        {
            int j = random.Next(i, n);
            var temp = Position[i];
            Position[i] = Position[j];
            Position[j] = temp;
        }
    }

    public void UpdateBestPosition()
    {
        if (Fitness < BestFitness)
        {
            BestFitness = Fitness;
            BestPosition = new List<int>(Position);
        }
    }

    public void ApplyVelocity()
    {
        foreach (var swap in Velocity)
        {
            int temp = Position[swap.Item1];
            Position[swap.Item1] = Position[swap.Item2];
            Position[swap.Item2] = temp;
        }
    }

    public void UpdateVelocity(List<int> globalBestPosition, double inertiaWeight, double cognitiveComponent, double socialComponent)
    {
        Velocity.Clear();
        for (int i = 0; i < Position.Count; i++)
        {
            if (random.NextDouble() < cognitiveComponent)
            {
                int swapIdx = BestPosition.IndexOf(Position[i]);
                if (i != swapIdx)
                    Velocity.Add(Tuple.Create(i, swapIdx));
            }

            if (random.NextDouble() < socialComponent)
            {
                int swapIdx = globalBestPosition.IndexOf(Position[i]);
                if (i != swapIdx)
                    Velocity.Add(Tuple.Create(i, swapIdx));
            }
        }
    }
}
