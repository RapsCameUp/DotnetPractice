using System;
using System.Collections.Generic;
using System.Drawing;
using System.Linq;
using System.Windows.Forms;

public partial class Form1 : Form
{
    private List<City> cities;
    private PSO pso;
    private Particle bestSolution;
    private Timer timer;
    private int iterationCount = 0;
    private const int maxIterationsWithoutImprovement = 500;
    private double bestDistanceSoFar = double.MaxValue;
    private int iterationsWithoutImprovement = 0;

    public Form1()
    {
        InitializeComponent();

        // Initialize cities
        cities = new List<City>()
        {
            new City(100, 100),
            new City(200, 100),
            new City(300, 200),
            new City(400, 300),
            new City(500, 400),
            new City(600, 100)
        };

        // Initialize PSO
        pso = new PSO(cities, swarmSize: 50);

        // Set up a timer to continuously run PSO optimization
        timer = new Timer();
        timer.Interval = 100; // Adjust this value to speed up/slow down visualization
        timer.Tick += Timer_Tick;
        timer.Start();
    }

    private void Timer_Tick(object sender, EventArgs e)
    {
        // Run one iteration of optimization
        pso.Optimize(iterations: 1);
        bestSolution = pso.GetBestSolution();
        iterationCount++;

        // Check for stopping condition
        if (bestSolution.BestFitness < bestDistanceSoFar)
        {
            bestDistanceSoFar = bestSolution.BestFitness;
            iterationsWithoutImprovement = 0;
        }
        else
        {
            iterationsWithoutImprovement++;
        }

        if (iterationsWithoutImprovement >= maxIterationsWithoutImprovement)
        {
            timer.Stop(); // Stop optimization if no improvement in a long time
            MessageBox.Show($"Optimization stopped after {iterationCount} iterations. Best distance: {bestDistanceSoFar}");
        }

        // Invalidate the form to trigger a redraw with the updated best solution
        this.Invalidate();
    }

    protected override void OnPaint(PaintEventArgs e)
    {
        base.OnPaint(e);
        if (bestSolution != null)
        {
            DrawCitiesAndPath(e.Graphics, bestSolution);
        }
    }

    private void DrawCitiesAndPath(Graphics g, Particle solution)
    {
        Pen pen = new Pen(Color.Black, 2);
        Brush cityBrush = new SolidBrush(Color.Red);
        Font font = new Font("Arial", 10);
        Brush textBrush = new SolidBrush(Color.Blue);

        // Draw cities as red dots
        for (int i = 0; i < cities.Count; i++)
        {
            City city = cities[i];
            g.FillEllipse(cityBrush, (float)city.X - 5, (float)city.Y - 5, 10, 10);
            g.DrawString($"City {i + 1}", font, textBrush, (float)city.X + 10, (float)city.Y);
        }

        // Draw the optimized path between the cities
        for (int i = 0; i < solution.Position.Count - 1; i++)
        {
            City city1 = cities[solution.Position[i]];
            City city2 = cities[solution.Position[i + 1]];
            g.DrawLine(pen, (float)city1.X, (float)city1.Y, (float)city2.X, (float)city2.Y);
        }

        // Draw the line from the last city back to the first
        City lastCity = cities[solution.Position.Last()];
        City firstCity = cities[solution.Position.First()];
        g.DrawLine(pen, (float)lastCity.X, (float)lastCity.Y, (float)firstCity.X, (float)firstCity.Y);

        // Display iteration count and best distance for debugging purposes
        g.DrawString($"Iteration: {iterationCount}", font, textBrush, 10, 10);
        g.DrawString($"Best Distance: {bestDistanceSoFar:F2}", font, textBrush, 10, 30);

        // Display the optimized solution path in text format
        string pathText = "Optimized Path: " + string.Join(" -> ", solution.Position.Select(i => $"City {i + 1}"));
        g.DrawString(pathText, font, textBrush, 10, 50);
    }
}
